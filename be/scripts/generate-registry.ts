/**
 * Generate ItemRegistry.ts with all item imports and exports
 *
 * Usage: npx ts-node be/scripts/generate-registry.ts
 */

import * as fs from 'fs';
import * as path from 'path';

interface ItemImport {
  className: string;
  relativePath: string;
  category: string;
}

/**
 * Find all TypeScript item definition files
 */
function findItemFiles(dir: string, baseDir: string): ItemImport[] {
  const items: ItemImport[] = [];

  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      items.push(...findItemFiles(fullPath, baseDir));
    } else if (entry.isFile() && entry.name.endsWith('.ts')) {
      const className = path.basename(entry.name, '.ts');
      const relativePath = './definitions/' + path.relative(baseDir, fullPath).replace(/\\/g, '/').replace('.ts', '');
      const category = path.relative(baseDir, path.dirname(fullPath)).split(path.sep)[0] || 'unknown';

      items.push({ className, relativePath, category });
    }
  }

  return items;
}

/**
 * Generate ItemRegistry.ts content
 */
function generateRegistry(items: ItemImport[]): string {
  const lines: string[] = [];

  // Header
  lines.push('/**');
  lines.push(' * Item Registry - Central registry for all item definitions');
  lines.push(' * Auto-generated by scripts/generate-registry.ts');
  lines.push(` * Generated: ${new Date().toISOString()}`);
  lines.push(' * DO NOT EDIT MANUALLY');
  lines.push(' */');
  lines.push('');
  lines.push("import { Item } from '@shared/types';");
  lines.push('');

  // Sort items by category then name
  const sortedItems = items.sort((a, b) => {
    if (a.category !== b.category) {
      return a.category.localeCompare(b.category);
    }
    return a.className.localeCompare(b.className);
  });

  // Group by category for comments
  let currentCategory = '';
  for (const item of sortedItems) {
    if (item.category !== currentCategory) {
      if (currentCategory !== '') {
        lines.push('');
      }
      lines.push(`// ${item.category.toUpperCase()}`);
      currentCategory = item.category;
    }

    lines.push(`import { ${item.className} } from '${item.relativePath}';`);
  }

  lines.push('');
  lines.push('/**');
  lines.push(' * Central registry for all item definitions');
  lines.push(' */');
  lines.push('export class ItemRegistry {');
  lines.push('  private static readonly items = new Map<string, Item>([');

  // Add all items to map
  for (const item of sortedItems) {
    lines.push(`    [${item.className}.itemId, ${item.className}],`);
  }

  lines.push('  ]);');
  lines.push('');
  lines.push('  /**');
  lines.push('   * Get an item definition by ID');
  lines.push('   */');
  lines.push('  static get(itemId: string): Item | undefined {');
  lines.push('    return this.items.get(itemId);');
  lines.push('  }');
  lines.push('');
  lines.push('  /**');
  lines.push('   * Check if an item exists');
  lines.push('   */');
  lines.push('  static has(itemId: string): boolean {');
  lines.push('    return this.items.has(itemId);');
  lines.push('  }');
  lines.push('');
  lines.push('  /**');
  lines.push('   * Get all item definitions');
  lines.push('   */');
  lines.push('  static getAll(): Item[] {');
  lines.push('    return Array.from(this.items.values());');
  lines.push('  }');
  lines.push('');
  lines.push('  /**');
  lines.push('   * Get all item IDs');
  lines.push('   */');
  lines.push('  static getAllIds(): string[] {');
  lines.push('    return Array.from(this.items.keys());');
  lines.push('  }');
  lines.push('');
  lines.push('  /**');
  lines.push('   * Get items by category');
  lines.push('   */');
  lines.push('  static getByCategory(category: string): Item[] {');
  lines.push('    return this.getAll().filter(item => item.category === category);');
  lines.push('  }');
  lines.push('');
  lines.push('  /**');
  lines.push('   * Get items by subcategory');
  lines.push('   */');
  lines.push('  static getBySubcategory(subcategory: string): Item[] {');
  lines.push('    return this.getAll().filter(item => item.subcategories?.includes(subcategory));');
  lines.push('  }');
  lines.push('');
  lines.push('  /**');
  lines.push('   * Get the total number of items');
  lines.push('   */');
  lines.push('  static get size(): number {');
  lines.push('    return this.items.size;');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Main function
 */
function main() {
  console.log('ðŸ”„ Generating ItemRegistry.ts...\n');

  const definitionsDir = path.join(__dirname, '../data/items/definitions');
  const outputPath = path.join(__dirname, '../data/items/ItemRegistry.ts');

  // Find all item files
  const items = findItemFiles(definitionsDir, definitionsDir);
  console.log(`Found ${items.length} item definitions`);

  // Generate registry content
  const content = generateRegistry(items);

  // Write to file
  fs.writeFileSync(outputPath, content, 'utf8');

  console.log(`âœ“ Generated ${outputPath}`);
  console.log(`âœ“ Registry contains ${items.length} items`);
}

// Run
main();
