/**
 * Generate registries for all definition types
 *
 * Usage: npx ts-node be/scripts/generate-all-registries.ts [type]
 * Types: monsters, abilities, recipes, vendors, all
 */

import * as fs from 'fs';
import * as path from 'path';

interface RegistryConfig {
  name: string;
  definitionsDir: string;
  outputFile: string;
  typeName: string;
  typeImportPath: string;
  idField: string;
  registryClassName: string;
  flatStructure?: boolean; // If true, doesn't have a definitions subdirectory
}

const REGISTRY_CONFIGS: Record<string, RegistryConfig> = {
  monsters: {
    name: 'Monsters',
    definitionsDir: 'data/monsters/definitions',
    outputFile: 'data/monsters/MonsterRegistry.ts',
    typeName: 'Monster',
    typeImportPath: '../../types/combat',
    idField: 'monsterId',
    registryClassName: 'MonsterRegistry'
  },
  abilities: {
    name: 'Abilities',
    definitionsDir: 'data/abilities/definitions',
    outputFile: 'data/abilities/AbilityRegistry.ts',
    typeName: 'Ability',
    typeImportPath: '../../types/combat',
    idField: 'abilityId',
    registryClassName: 'AbilityRegistry'
  },
  recipes: {
    name: 'Recipes',
    definitionsDir: 'data/recipes',
    outputFile: 'data/recipes/RecipeRegistry.ts',
    typeName: 'Recipe',
    typeImportPath: '../../types/crafting',
    idField: 'recipeId',
    registryClassName: 'RecipeRegistry'
  },
  vendors: {
    name: 'Vendors',
    definitionsDir: 'data/vendors',
    outputFile: 'data/vendors/VendorRegistry.ts',
    typeName: 'Vendor',
    typeImportPath: '../../types/crafting',
    idField: 'vendorId',
    registryClassName: 'VendorRegistry',
    flatStructure: true  // Vendors don't have a definitions subdirectory
  },
  locations: {
    name: 'Locations',
    definitionsDir: 'data/locations/definitions',
    outputFile: 'data/locations/LocationRegistry.ts',
    typeName: 'Location',
    typeImportPath: '../../types/locations',
    idField: 'locationId',
    registryClassName: 'LocationRegistry'
  },
  activities: {
    name: 'Activities',
    definitionsDir: 'data/locations/activities',
    outputFile: 'data/locations/ActivityRegistry.ts',
    typeName: 'ActivityUnion',
    typeImportPath: '../../types/locations',
    idField: 'activityId',
    registryClassName: 'ActivityRegistry',
    flatStructure: true
  },
  facilities: {
    name: 'Facilities',
    definitionsDir: 'data/locations/facilities',
    outputFile: 'data/locations/FacilityRegistry.ts',
    typeName: 'Facility',
    typeImportPath: '../../types/locations',
    idField: 'facilityId',
    registryClassName: 'FacilityRegistry',
    flatStructure: true
  },
  biomes: {
    name: 'Biomes',
    definitionsDir: 'data/locations/biomes',
    outputFile: 'data/locations/BiomeRegistry.ts',
    typeName: 'Biome',
    typeImportPath: '../../types/locations',
    idField: 'biomeId',
    registryClassName: 'BiomeRegistry',
    flatStructure: true
  },
  dropTables: {
    name: 'DropTables',
    definitionsDir: 'data/locations/drop-tables',
    outputFile: 'data/locations/DropTableRegistry.ts',
    typeName: 'DropTable',
    typeImportPath: '../../types/locations',
    idField: 'dropTableId',
    registryClassName: 'DropTableRegistry',
    flatStructure: true
  }
};

/**
 * Find all TypeScript files recursively
 */
function findTsFiles(dir: string, baseDir: string): Array<{ className: string; relativePath: string; subdirectory?: string }> {
  const results: Array<{ className: string; relativePath: string; subdirectory?: string }> = [];

  if (!fs.existsSync(dir)) {
    return results;
  }

  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      // Recursively find files in subdirectories
      const subResults = findTsFiles(fullPath, baseDir);
      const subdirName = path.relative(baseDir, path.dirname(fullPath + '/dummy')).split(path.sep)[0];

      subResults.forEach(result => {
        results.push({
          ...result,
          subdirectory: subdirName !== '.' ? subdirName : undefined
        });
      });
    } else if (entry.isFile() && entry.name.endsWith('.ts')) {
      const className = path.basename(entry.name, '.ts');
      const relativePath = './definitions/' + path.relative(baseDir, fullPath).replace(/\\/g, '/').replace('.ts', '');

      results.push({ className, relativePath });
    }
  }

  return results;
}

/**
 * Generate registry file content
 */
function generateRegistry(config: RegistryConfig, files: Array<{ className: string; relativePath: string; subdirectory?: string }>): string {
  const lines: string[] = [];

  // Header
  lines.push('/**');
  lines.push(` * ${config.name} Registry - Central registry for all ${config.name.toLowerCase()}`);
  lines.push(' * Auto-generated by scripts/generate-all-registries.ts');
  lines.push(` * Generated: ${new Date().toISOString()}`);
  lines.push(' * DO NOT EDIT MANUALLY');
  lines.push(' */');
  lines.push('');
  lines.push(`import { ${config.typeName} } from '${config.typeImportPath}';`);
  lines.push('');

  // Group by subdirectory
  const grouped = new Map<string, typeof files>();
  for (const file of files) {
    const key = file.subdirectory || '_root';
    if (!grouped.has(key)) {
      grouped.set(key, []);
    }
    grouped.get(key)!.push(file);
  }

  // Imports
  for (const [subdir, groupFiles] of Array.from(grouped.entries()).sort()) {
    if (subdir !== '_root') {
      lines.push(`// ${subdir.toUpperCase()}`);
    }
    for (const file of groupFiles.sort((a, b) => a.className.localeCompare(b.className))) {
      lines.push(`import { ${file.className} } from '${file.relativePath}';`);
    }
    if (subdir !== '_root') {
      lines.push('');
    }
  }

  lines.push('');
  lines.push('/**');
  lines.push(` * Central registry for all ${config.name.toLowerCase()}`);
  lines.push(' */');
  lines.push(`export class ${config.registryClassName} {`);
  lines.push(`  private static readonly items = new Map<string, ${config.typeName}>([`);

  // Add all items to map
  const sortedFiles = files.sort((a, b) => a.className.localeCompare(b.className));
  for (const file of sortedFiles) {
    lines.push(`    [${file.className}.${config.idField}, ${file.className}],`);
  }

  lines.push('  ]);');
  lines.push('');
  lines.push('  /**');
  lines.push(`   * Get a ${config.typeName.toLowerCase()} by ID`);
  lines.push('   */');
  lines.push(`  static get(id: string): ${config.typeName} | undefined {`);
  lines.push('    return this.items.get(id);');
  lines.push('  }');
  lines.push('');
  lines.push('  /**');
  lines.push(`   * Check if a ${config.typeName.toLowerCase()} exists`);
  lines.push('   */');
  lines.push('  static has(id: string): boolean {');
  lines.push('    return this.items.has(id);');
  lines.push('  }');
  lines.push('');
  lines.push('  /**');
  lines.push(`   * Get all ${config.name.toLowerCase()}`);
  lines.push('   */');
  lines.push(`  static getAll(): ${config.typeName}[] {`);
  lines.push('    return Array.from(this.items.values());');
  lines.push('  }');
  lines.push('');
  lines.push('  /**');
  lines.push(`   * Get all ${config.typeName.toLowerCase()} IDs`);
  lines.push('   */');
  lines.push('  static getAllIds(): string[] {');
  lines.push('    return Array.from(this.items.keys());');
  lines.push('  }');
  lines.push('');
  lines.push('  /**');
  lines.push(`   * Get the total number of ${config.name.toLowerCase()}`);
  lines.push('   */');
  lines.push('  static get size(): number {');
  lines.push('    return this.items.size');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Main function
 */
function main() {
  const args = process.argv.slice(2);
  const targetType = args[0] || 'all';

  console.log('üîÑ Generating registries...\n');

  let totalGenerated = 0;

  if (targetType === 'all') {
    for (const [key, config] of Object.entries(REGISTRY_CONFIGS)) {
      console.log(`üì¶ Generating ${config.registryClassName}...`);

      const definitionsPath = path.join(__dirname, '..', config.definitionsDir);
      const files = findTsFiles(definitionsPath, definitionsPath);

      const registryContent = generateRegistry(config, files);
      const outputPath = path.join(__dirname, '..', config.outputFile);

      fs.writeFileSync(outputPath, registryContent, 'utf8');

      console.log(`‚úì Generated ${outputPath}`);
      console.log(`‚úì Registry contains ${files.length} ${config.name.toLowerCase()}\n`);
      totalGenerated++;
    }
  } else if (REGISTRY_CONFIGS[targetType]) {
    const config = REGISTRY_CONFIGS[targetType];
    console.log(`üì¶ Generating ${config.registryClassName}...`);

    const definitionsPath = path.join(__dirname, '..', config.definitionsDir);
    const files = findTsFiles(definitionsPath, definitionsPath);

    const registryContent = generateRegistry(config, files);
    const outputPath = path.join(__dirname, '..', config.outputFile);

    fs.writeFileSync(outputPath, registryContent, 'utf8');

    console.log(`‚úì Generated ${outputPath}`);
    console.log(`‚úì Registry contains ${files.length} ${config.name.toLowerCase()}`);
    totalGenerated++;
  } else {
    console.error(`‚ùå Unknown type: ${targetType}`);
    console.log('Valid types: monsters, abilities, recipes, vendors, all');
    process.exit(1);
  }

  console.log(`\n‚úÖ Generated ${totalGenerated} registries\n`);
}

main();
